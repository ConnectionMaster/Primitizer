// Add Menus To Interface API
integer link_interface_add = 0x3E8;

// Cancel Dialog Request
integer link_interface_cancel = 0x7D0;

// Cancel Button Is Triggered.
integer link_interface_cancelled = 0xBB8; // Message sent from link_interface_cancel to link message to be used in other scripts.

// Clear Dialog Request
integer link_interface_clear = 0xFA0;

// Display Dialog Interface
integer link_interface_dialog = 0x1388;

// Dialog Not Found
integer link_interface_not_found = 0x1770;

// Reshow Last Dialog Displayed
integer link_interface_reshow = 0x1B58;

// A Button Is Triggered, Or OK Is Triggered
integer link_interface_response = 0x1F40;

// Display Dialog
integer link_interface_show = 0x2328;

// Play Sound When Dialog Button Touched
integer link_interface_sound = 0x2710;

// Display Textbox Interface
integer link_interface_textbox = 0x2AF8;

// No Button Is Hit, Or Ignore Is Hit
integer link_interface_timeout = 0x2EE0;

// Define API Seperator For Parsing String Data
//string dialog_seperator = "||";
//
// Dialog Time-Out Defined In Dialog Menu Creation.
//integer dialog_timeout = 30;


// define a channel for listening
integer listen_channel = -3839;

// Define A Channel Handle To Remove listen_channel
integer listen_handle;

// define a list containing all the possible menu items
list ALL_MENU_ITEMS = ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26"];

// the maximum number of buttons that can be displayed in the dialog at one time
integer dialog_max_buttons = 12;

integer DIALOG_LAST_PAGE;
//integer DIALOG_PAGE_NUMBER = 0;
// the dialog's message
string dialog_menu_message = "Pick a Number";

// define tokens for the Prev and Next operations
string button_back = "◄ Back";
string button_next = "Next ►";
string BUTTON_END = "■ End";

list inventory(integer type)
{
    list inventory = [];
    integer index;
    integer count = llGetInventoryNumber(type);
    string  inventory_name;
    for(index=0; index<count; index++)
    {
        inventory_name = llGetInventoryName(type, index);
        inventory += [inventory_name];
    }
    return inventory;
}

list TEXTURE_BUTTONS = [];
initialize()
{
	TEXTURE_BUTTONS = inventory(INVENTORY_TEXTURE);
}
// ==============================================================
// You may not need to change anything below this section, but
// feel free to look through the code if you would like to modify
// the basic functionality.
// ==============================================================

// the number of menu items available (calculated in state_entry)
integer dialog_items_count = 0;

// define a cycle number to keep track of which sublist to display
integer dialog_cycle_index = 0;

integer DIALOG_PAGE;
// figure out which sublist cycle should be displayed
//
// items can be any list that has a bunch of items in it
// direction can be button_back, button_next, or a blank String
list cycle(list items, string direction)
{
	// the sublist that will be generated by the next few operations
	list sublist = [];

	// calculate the number of items available
	dialog_items_count = llGetListLength(items);

    DIALOG_LAST_PAGE = llCeil((float)dialog_items_count / (float)dialog_max_buttons);
	llSay(DEBUG_CHANNEL, "DIALOG_LAST_PAGE:" + (string)DIALOG_LAST_PAGE );
    if (DIALOG_PAGE > DIALOG_LAST_PAGE)
    {
        DIALOG_PAGE = DIALOG_LAST_PAGE;
    }
    if (DIALOG_PAGE < 1)
    {
        DIALOG_PAGE = 1;
    }
	// check to see what the direction was (if one was specified)
	if(direction == button_back)
	{
		// display the previous cycle if the preconditions are met
		if(dialog_cycle_index > 0)
		{
			// the index can be cycled backward safely
			dialog_cycle_index--;
		}
	}
	else if(direction == button_next)
	{
		// display the next cycle if the preconditions are met
		dialog_cycle_index++;
	}

	// figure out which button cycle needs to be displayed
	if(dialog_cycle_index == 0) // first cycle
	{
		// check the number of available items
		if(dialog_items_count <= dialog_max_buttons)
		{
			// the entire list can be displayed as one complete dialog
			sublist = llList2List(items, 0, dialog_items_count - 1);
		}
		else
		{
			// grab the sublist from the beginning until dialog_max_buttons - 2
			// to take into account the need for a button_next item
			sublist = llList2List(items, 0, dialog_max_buttons - 2);

			// append the button_next item to the end of the cycle
			sublist += [button_next];
		}
	}
	else // second...n cycle
	{
		// make sure we did not go over the list bounds
		integer start_index = 0;

		// (dialog_max_buttons - 1) represents the first cycle with the
		// NEXT button
		//
		// ((dialog_cycle_index - 1) * (dialog_max_buttons - 2)) calculates
		// every cycle after the first (with NEXT and PREV buttons)
		start_index = (dialog_max_buttons - 1) + ((dialog_cycle_index - 1) * (dialog_max_buttons - 2));

		// calculate how many items we'll have left after this cycle
		integer items_left = dialog_items_count - start_index;

		// check to see if we'll have another cycle after this one
		if(items_left > dialog_max_buttons - 2)
		{
			// we can fill another dialog with PREV and NEXT buttons, so
			// this is just another regular cycle (with dialog_max_buttons - 3) to ensure that
			// the total number of items pulled from ALL_MENU_ITEMS is actually equal to
			// (dialog_max_buttons - 2)
			sublist = llList2List(items, start_index, start_index + (dialog_max_buttons - 3));

			// add the button_back button and button_next button
			sublist = [button_back] + sublist + [button_next];
		}
		else
		{
			// we can finish the list along with a PREV button, so this
			// is the final cycle for the list
			sublist = llList2List(items, start_index, dialog_items_count - 1);

			// add the button_back button and BUTTON_END to the beginning of the cycle
			sublist = [button_back] + sublist + [BUTTON_END];
		}
	}

	// return the generated sublist cycle
	return sublist;
}

default
{
	state_entry()
	{
		DIALOG_PAGE = 1;
		DIALOG_LAST_PAGE = llCeil((float)llGetListLength(TEXTURE_BUTTONS) / (float)dialog_max_buttons);
		
		listen_handle = llListen(listen_channel, "", llGetOwner(), "");
		initialize();
		//llListenRemove(listen_handle);
		//DIALOG_MAX_PAGES = (dialog_items_count / dialog_max_buttons);
	}

    changed(integer changes)
    {
        if(changes & CHANGED_INVENTORY) initialize();
    }

	listen(integer channel, string name, key id, string message)
	{
        if (message == BUTTON_END)
        {
            llSetTimerEvent(0.1);
            return;   
        }
		if(message == button_next)
		{
			++DIALOG_PAGE;
			string DIALOG_MESSAGE_PAGES = "(Page " + (string)DIALOG_PAGE + " Of " + (string)DIALOG_LAST_PAGE + ")\n" + dialog_menu_message;
			llDialog(llGetOwner(), DIALOG_MESSAGE_PAGES, cycle(TEXTURE_BUTTONS, button_next), listen_channel);
		}
		else if(message == button_back)
		{
			--DIALOG_PAGE;
            string DIALOG_MESSAGE_PAGES = "(Page " + (string)DIALOG_PAGE + " Of " + (string)DIALOG_LAST_PAGE + ")\n" + dialog_menu_message;
			llDialog(llGetOwner(), DIALOG_MESSAGE_PAGES, cycle(TEXTURE_BUTTONS, button_back), listen_channel);
		}
		else
		{
			if(llGetInventoryType(message) == INVENTORY_TEXTURE) llSetTexture(message, ALL_SIDES);
		}
	}

	touch_start(integer total_number)
	{
		DIALOG_PAGE = 1;
		DIALOG_LAST_PAGE = llCeil((float)llGetListLength(TEXTURE_BUTTONS) / (float)dialog_max_buttons);
        string DIALOG_MESSAGE_PAGES = "(Page " + (string)DIALOG_PAGE + " Of " + (string)DIALOG_LAST_PAGE + ")\n" + dialog_menu_message;
		if(llDetectedKey(0) == llGetOwner())
		{
			llDialog(llGetOwner(), DIALOG_MESSAGE_PAGES, cycle(TEXTURE_BUTTONS, ""), listen_channel);
		}
	}
}