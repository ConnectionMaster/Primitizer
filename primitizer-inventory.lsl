// define a channel for listening
integer LISTEN_CHANNEL = -3839;

// Define A Channel Handle To Remove LISTEN_CHANNEL
integer LISTEN_HANDLE;

// define a list containing all the possible menu items
list ALL_MENU_ITEMS = ["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26"];

// the maximum number of buttons that can be displayed in the dialog at one time
integer DIALOG_MAX_BUTTONS = 12;

integer DIALOG_LAST_PAGE;
//integer DIALOG_PAGE_NUMBER = 0;
// the dialog's message
string DIALOG_MENU_MESSAGE = "Pick a Number";

// define tokens for the Prev and Next operations
string BUTTON_BACK = "◄ Back";
string BUTTON_NEXT = "Next ►";
string BUTTON_END = "■ End";

list inventory(integer type)
{
    list inventory = [];
    integer index;
    integer count = llGetInventoryNumber(type);
    string  inventory_name;
    for(index=0; index<count; index++)
    {
        inventory_name = llGetInventoryName(type, index);
        inventory += [inventory_name];
    }
    return inventory;
}

list TEXTURE_BUTTONS = [];
initialize()
{
	TEXTURE_BUTTONS = inventory(INVENTORY_TEXTURE);
}
// ==============================================================
// You may not need to change anything below this section, but
// feel free to look through the code if you would like to modify
// the basic functionality.
// ==============================================================

// the number of menu items available (calculated in state_entry)
integer DIALOG_ITEMS_COUNT = 0;

// define a cycle number to keep track of which sublist to display
integer DIALOG_CYCLE_INDEX = 0;

integer DIALOG_PAGE;
// figure out which sublist cycle should be displayed
//
// items can be any list that has a bunch of items in it
// direction can be BUTTON_BACK, BUTTON_NEXT, or a blank String
list cycle(list items, string direction)
{
	// the sublist that will be generated by the next few operations
	list sublist = [];

	// calculate the number of items available
	DIALOG_ITEMS_COUNT = llGetListLength(items);

	//DIALOG_MAX_PAGES = (DIALOG_ITEMS_COUNT / DIALOG_MAX_BUTTONS);

    DIALOG_LAST_PAGE = llCeil((float)DIALOG_ITEMS_COUNT / (float)DIALOG_MAX_BUTTONS);
	llSay(DEBUG_CHANNEL, "DIALOG_LAST_PAGE:" + (string)DIALOG_LAST_PAGE );
    if (DIALOG_PAGE > DIALOG_LAST_PAGE)
    {
        DIALOG_PAGE = DIALOG_LAST_PAGE;
    }
    if (DIALOG_PAGE < 1)
    {
        DIALOG_PAGE = 1;
    }
	// check to see what the direction was (if one was specified)
	if(direction == BUTTON_BACK)
	{
		// display the previous cycle if the preconditions are met
		if(DIALOG_CYCLE_INDEX > 0)
		{
			// the index can be cycled backward safely
			DIALOG_CYCLE_INDEX--;
		}
	}
	else if(direction == BUTTON_NEXT)
	{
		// display the next cycle if the preconditions are met
		DIALOG_CYCLE_INDEX++;
	}

	// figure out which button cycle needs to be displayed
	if(DIALOG_CYCLE_INDEX == 0) // first cycle
	{
		// check the number of available items
		if(DIALOG_ITEMS_COUNT <= DIALOG_MAX_BUTTONS)
		{
			// the entire list can be displayed as one complete dialog
			sublist = llList2List(items, 0, DIALOG_ITEMS_COUNT - 1);
		}
		else
		{
			// grab the sublist from the beginning until DIALOG_MAX_BUTTONS - 2
			// to take into account the need for a BUTTON_NEXT item
			sublist = llList2List(items, 0, DIALOG_MAX_BUTTONS - 2);

			// append the BUTTON_NEXT item to the end of the cycle
			sublist += [BUTTON_NEXT];
		}
	}
	else // second...n cycle
	{
		// make sure we did not go over the list bounds
		integer start_index = 0;

		// (DIALOG_MAX_BUTTONS - 1) represents the first cycle with the
		// NEXT button
		//
		// ((DIALOG_CYCLE_INDEX - 1) * (DIALOG_MAX_BUTTONS - 2)) calculates
		// every cycle after the first (with NEXT and PREV buttons)
		start_index = (DIALOG_MAX_BUTTONS - 1) + ((DIALOG_CYCLE_INDEX - 1) * (DIALOG_MAX_BUTTONS - 2));

		// calculate how many items we'll have left after this cycle
		integer items_left = DIALOG_ITEMS_COUNT - start_index;

		// check to see if we'll have another cycle after this one
		if(items_left > DIALOG_MAX_BUTTONS - 2)
		{
			// we can fill another dialog with PREV and NEXT buttons, so
			// this is just another regular cycle (with DIALOG_MAX_BUTTONS - 3) to ensure that
			// the total number of items pulled from ALL_MENU_ITEMS is actually equal to
			// (DIALOG_MAX_BUTTONS - 2)
			sublist = llList2List(items, start_index, start_index + (DIALOG_MAX_BUTTONS - 3));

			// add the BUTTON_BACK button and BUTTON_NEXT button
			sublist = [BUTTON_BACK] + sublist + [BUTTON_NEXT];
		}
		else
		{
			// we can finish the list along with a PREV button, so this
			// is the final cycle for the list
			sublist = llList2List(items, start_index, DIALOG_ITEMS_COUNT - 1);

			// add the BUTTON_BACK button and BUTTON_END to the beginning of the cycle
			sublist = [BUTTON_BACK] + sublist + [BUTTON_END];
		}
	}

	// return the generated sublist cycle
	return sublist;
}

default
{
	state_entry()
	{
		DIALOG_PAGE = 1;
		LISTEN_HANDLE = llListen(LISTEN_CHANNEL, "", llGetOwner(), "");
		initialize();
		//llListenRemove(LISTEN_HANDLE);
		//DIALOG_MAX_PAGES = (DIALOG_ITEMS_COUNT / DIALOG_MAX_BUTTONS);
	}

    changed(integer changes)
    {
        if(changes & CHANGED_INVENTORY) initialize();
    }

	listen(integer channel, string name, key id, string message)
	{
        if (message == BUTTON_END)
        {
            llSetTimerEvent(0.1);
            return;   
        }
		if(message == BUTTON_NEXT)
		{
			++DIALOG_PAGE;
			string DIALOG_MESSAGE_PAGES = "(Page " + (string)DIALOG_PAGE + " Of " + (string)DIALOG_LAST_PAGE + ")\n" + DIALOG_MENU_MESSAGE;
			llDialog(llGetOwner(), DIALOG_MESSAGE_PAGES, cycle(TEXTURE_BUTTONS, BUTTON_NEXT), LISTEN_CHANNEL);
		}
		else if(message == BUTTON_BACK)
		{
			--DIALOG_PAGE;
            string DIALOG_MESSAGE_PAGES = "(Page " + (string)DIALOG_PAGE + " Of " + (string)DIALOG_LAST_PAGE + ")\n" + DIALOG_MENU_MESSAGE;
			llDialog(llGetOwner(), DIALOG_MESSAGE_PAGES, cycle(TEXTURE_BUTTONS, BUTTON_BACK), LISTEN_CHANNEL);
		}
		else
		{
			if(llGetInventoryType(message) == INVENTORY_TEXTURE) llSetTexture(message, ALL_SIDES);
		}
	}

	touch_start(integer total_number)
	{
		DIALOG_PAGE = 1;
        string DIALOG_MESSAGE_PAGES = "(Page " + (string)DIALOG_PAGE + " Of " + (string)DIALOG_LAST_PAGE + ")\n" + DIALOG_MENU_MESSAGE;
		if(llDetectedKey(0) == llGetOwner())
		{
			llDialog(llGetOwner(), DIALOG_MESSAGE_PAGES, cycle(TEXTURE_BUTTONS, ""), LISTEN_CHANNEL);
		}
	}
}