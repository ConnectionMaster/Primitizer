// Enable/Disable Debug Mode
integer LINK_INTERFACE_DEBUG = 17000; // Send message too LINK_INTERFACE_ENABLE_DEBUG or LINK_INTERFACE_DISABLE_DEBUG based on toggle state

// Add Menus To Interface API
integer LINK_INTERFACE_ADD = 15002;

// Cancel Dialog Request
integer LINK_INTERFACE_CANCEL = 14012;

// Cancel Is Hit For LINK_INTERFACE_NUMERIC
integer LINK_INTERFACE_CANCELLED = 14006; // Message sent from LINK_INTERFACE_CANCEL to link message to be used in other scripts.

// Clear Dialog Request
integer LINK_INTERFACE_CLEAR = 15001;

// Display Dialog Interface
integer LINK_INTERFACE_DIALOG = 14001;

// Notify Dialog Type
integer LINK_INTERFACE_NOTIFY = 14004;

// Dialog Not Found
integer LINK_INTERFACE_NOT_FOUND = 15010;

// Display Numeric Interface
integer LINK_INTERFACE_NUMERIC = 14005;

// Reshow Last Dialog Displayed
integer LINK_INTERFACE_RESHOW = 14011;

// A Button Is Hit, Or OK Is Hit For LINK_INTERFACE_NUMERIC
integer LINK_INTERFACE_RESPONSE = 14002;

// Display Dialog
integer LINK_INTERFACE_SHOW = 15003;

// Play Sound When Dialog Button Touched
integer LINK_INTERFACE_SOUND = 15021;

// Display Textbox Interface
integer LINK_INTERFACE_TEXTBOX = 14007;

// No Button Is Hit, Or Ignore Is Hit
integer LINK_INTERFACE_TIMEOUT = 14003;

// ==============================================================
// You may not need to change anything below this section, but
// feel free to look through the code if you would like to modify
// the basic functionality.
// ==============================================================

// Define A Channel For Listening

integer PRIMITIZER_CHANNEL;

// Define A Channel Handle To Remove PRIMITIZER_CHANNEL
integer PRIMITIZER_HANDLE;

// Define API Seperator For Parsing String Data
string DIALOG_SEPERATOR = "||";

// Define A List Containing All The Possible Menu Buttons

//list DIALOG_MENU_BUTTONS = ["Options", "Functions", "Help"];
//list DIALOG_MENU_RETURNS = ["SYSTEM_OPTIONS", "SYSTEM_FUNCTIONS", "SYSTEM_HELP"];

// Define A List Containing All The Possible Menu Buttons
list DIALOG_MENU_BUTTONS = [];

// List Of Packed Menus Command, In Order Of DIALOG_MENU_ID_NAMES
list DIALOG_MENU_COMMANDS = []; //DIALOG_MENU_MESSAGE||DIALOG_TIMEOUT||DIALOG_MENU_BUTTONS||DIALOG_MENU_RETURNS

// Define A List Containing All The Possible Menu Names
list DIALOG_MENU_ID_NAMES = [];

// Define A List Containing All The Possible Menu Returns
list DIALOG_MENU_RETURNS = [];

// The Maximum Number Of Buttons That Can Be Displayed In The Dialog At One Time
integer DIALOG_MAX_BUTTONS = 12;

// The Number Of Menu Items Available.
integer DIALOG_ITEMS_COUNT = 0;

// Define Cycle Number To Keep Track Of Which DIALOG_ITEMS_SUBLIST To Display
integer DIALOG_CYCLE_INDEX = 0;

// Previous Called Menu Index
integer previous_index = 0;

// Message To Be Shown With The Dialog
string DIALOG_MENU_MESSAGE = "Pick a Number";

// define tokens for the Prev and Next operations
string BUTTON_BACK = "◄ Back";
string BUTTON_NEXT = "Next ►";

list sort(list buttons)
{
    return llList2List(buttons, -3, -1) + llList2List(buttons, -6, -4) +
        llList2List(buttons, -9, -7) + llList2List(buttons, -12, -10);
}

// figure out which sublist cycle should be displayed
//
// items can be any list that has a bunch of items in it
// direction can be BUTTON_BACK, BUTTON_NEXT, or a blank String
list pagination(list items, string direction)
{
    // the sublist that will be generated by the next few operations
    list sublist = [];

    // calculate the number of items available
    DIALOG_ITEMS_COUNT = llGetListLength(items);

    // check to see what the direction was (if one was specified)
    if(direction == BUTTON_BACK)
    {
        // display the previous cycle if the preconditions are met
        if(DIALOG_CYCLE_INDEX > 0)
        {
            // the index can be cycled backward safely
            DIALOG_CYCLE_INDEX--;
        }
    }
    else if(direction == BUTTON_NEXT)
    {
        // display the next cycle if the preconditions are met
        DIALOG_CYCLE_INDEX++;
    }

    // figure out which button cycle needs to be displayed
    if(DIALOG_CYCLE_INDEX == 0) // first cycle
    {
        // check the number of available items
        if(DIALOG_ITEMS_COUNT <= DIALOG_MAX_BUTTONS)
        {
            // the entire list can be displayed as one complete dialog
            sublist = llList2List(items, 0, DIALOG_ITEMS_COUNT - 1);
        }
        else
        {
            // grab the sublist from the beginning until DIALOG_MAX_BUTTONS - 2
            // to take into account the need for a BUTTON_NEXT item
            sublist = llList2List(items, 0, DIALOG_MAX_BUTTONS - 2);

            // append the BUTTON_NEXT item to the end of the cycle
            sublist += [BUTTON_NEXT];
        }
    }
    else // second...n cycle
    {
        // make sure we did not go over the list bounds
        integer start_index = 0;

        // (DIALOG_MAX_BUTTONS - 1) represents the first cycle with the
        // NEXT button
        //
        // ((DIALOG_CYCLE_INDEX - 1) * (DIALOG_MAX_BUTTONS - 2)) calculates
        // every cycle after the first (with NEXT and PREV buttons)
        start_index = (DIALOG_MAX_BUTTONS - 1) + ((DIALOG_CYCLE_INDEX - 1) * (DIALOG_MAX_BUTTONS - 2));

        // calculate how many items we'll have left after this cycle
        integer items_left = DIALOG_ITEMS_COUNT - start_index;

        // check to see if we'll have another cycle after this one
        if(items_left > DIALOG_MAX_BUTTONS - 2)
        {
            // we can fill another dialog with PREV and NEXT buttons, so
            // this is just another regular cycle (with DIALOG_MAX_BUTTONS - 3) to ensure that
            // the total number of items pulled from DIALOG_MENU_BUTTONS is actually equal to
            // (DIALOG_MAX_BUTTONS - 2)
            sublist = llList2List(items, start_index, start_index + (DIALOG_MAX_BUTTONS - 3));

            // add the PREV button and NEXT button
            sublist = [BUTTON_BACK] + sublist + [BUTTON_NEXT];
        }
        else
        {
            // we can finish the list along with a PREV button, so this
            // is the final cycle for the list
            sublist = llList2List(items, start_index, DIALOG_ITEMS_COUNT - 1);

            // add the PREV button to the beginning of the cycle
            sublist = [BUTTON_BACK] + sublist;
        }
    }

    // return the generated sublist cycle
	// @todo sort list before next/back buttons are added so they are not sorted into the mix.
    return sort(sublist);
}

clear_dialog()
{
    DIALOG_MENU_BUTTONS = [];
	DIALOG_MENU_ID_NAMES = [];
	previous_index = 0;
}

add_dialog(string name, string message, list buttons, list returns, integer timeout)
{
    string packed_message = message + DIALOG_SEPERATOR + (string)timeout;

    integer i;
    integer count = llGetListLength(buttons);
    for(i=0; i<count; i++)
    {
        packed_message += DIALOG_SEPERATOR + llList2String(buttons, i) + DIALOG_SEPERATOR + llList2String(returns, i);
    }
    integer index = llListFindList(DIALOG_MENU_ID_NAMES, [name]);
    if(index >= 0) //!= -1
        DIALOG_MENU_COMMANDS = llListReplaceList(DIALOG_MENU_COMMANDS, [packed_message], index, index);
    else
    {
        DIALOG_MENU_ID_NAMES += [name];
        DIALOG_MENU_COMMANDS += [packed_message];
    }
}

// temp function for debug only
link_debugged(integer sender_num, integer num, string str, key id)
{
	string message = "\n" + "sender_num = " + (string)sender_num + "\n";
	message += "num = " + (string)num + "\n";
	message += "str = " + (string)str + "\n";
	message += "id = " + (string)id + "\n";
	//llOwnerSay(message);
}

response_dialog(integer sender_num, integer num, string str, key id)
{
	list data = llParseString2List(str, [DIALOG_SEPERATOR], []);
	link_debugged(sender_num, num, str, id);
    if(num == LINK_INTERFACE_DIALOG)
    {
		//llOwnerSay("DEBUG:LINK_INTERFACE_DIALOG");
		//llOwnerSay("DEBUG:" + llDumpList2String(data, DIALOG_SEPERATOR));
	}
	else
	{
		request_dialog(sender_num, num, str, id);
	}
}

request_dialog(integer sender_num, integer num, string str, key id)
{
	list data = llParseString2List(str, [DIALOG_SEPERATOR], []);
	link_debugged(sender_num, num, str, id);
    if(num == LINK_INTERFACE_RESPONSE)
    {
        //llOwnerSay("DEBUG:LINK_INTERFACE_RESPONSE");
        if(llGetSubString(str, 0, 6) == "SYSTEM_")
        {
            str = llDeleteSubString(str, 0, 6);
			show_dialog(str, id);
        }
	}
    else if(num == LINK_INTERFACE_CLEAR)
    {
        //llOwnerSay("DEBUG:LINK_INTERFACE_CLEAR");
		clear_dialog();
    }
    else if(num == LINK_INTERFACE_ADD)
    {
		//llOwnerSay("DEBUG:LINK_INTERFACE_ADD");
	}
    else if(num == LINK_INTERFACE_SHOW)
    {
		//llOwnerSay("DEBUG:LINK_INTERFACE_SHOW");
	}
    else if(num == LINK_INTERFACE_SOUND)
    {
		//llOwnerSay("DEBUG:LINK_INTERFACE_SOUND");
	}
    else if(num == LINK_INTERFACE_DIALOG)
    {
		//llOwnerSay("DEBUG:LINK_INTERFACE_DIALOG");
		//llOwnerSay("DEBUG:" + llDumpList2String(data, DIALOG_SEPERATOR));
	}
}

integer IsValidScene(string name)
{
    if (~llListFindList(DIALOG_MENU_BUTTONS, [name]))
        return TRUE;
    return FALSE;
}

integer show_dialog(string name, key id)
{
    //if(llGetListLength(DIALOG_MENU_ID_NAMES) <= 0) return FALSE;

    integer index;
    if(name != "")
    {
        index = llListFindList(DIALOG_MENU_ID_NAMES, [name]);
        if(index < 0) return FALSE;
    }
    else index = previous_index;

    previous_index = index;

    string packed_message = llList2String(DIALOG_MENU_COMMANDS, index);

    //if(SOUND_UUID != NULL_KEY) llTriggerSound(SOUND_UUID, SOUND_VOLUME); 
    llMessageLinked(LINK_THIS, LINK_INTERFACE_DIALOG, packed_message, id);
    return TRUE;
}

/*
integer show_dialog(string name, key id)
{
    if (name != "")
    {
        integer index = llListFindList(DIALOG_MENU_BUTTONS, [name]);
		llOwnerSay("index:" + (string)index);
        if (index != -1)
        {
            llMessageLinked(LINK_THIS, LINK_INTERFACE_DIALOG, llList2String(DIALOG_MENU_RETURNS, index), id);
            return TRUE;
        }
        else
        {
            // dialog not found
			llMessageLinked(LINK_THIS, LINK_INTERFACE_NOT_FOUND, name, id);
            return FALSE;
        }
    }
    else
    {
        // dialog name not set
		llMessageLinked(LINK_THIS, LINK_INTERFACE_NOT_FOUND, "", id);
        return FALSE;
    }
}
*/

default
{
    state_entry()
    {
        // Listen On The Specified Channel And Display Dialog
        // @TODO Remove This Later and move to link message
        PRIMITIZER_HANDLE = llListen(PRIMITIZER_CHANNEL, "", llGetOwner(), "");
		//llListenRemove(PRIMITIZER_HANDLE);
    }

    changed(integer change)
    {
        // check to see if the object owner changed
        if(change & CHANGED_OWNER)
        {
            // reset the script so calls to llGetOwner()
            // will correctly reference the new owner
            llResetScript();
        }
    }

    link_message(integer sender_num, integer num, string str, key id)
    {
        response_dialog(sender_num, num, str, id);
    }

    listen(integer channel, string name, key id, string message)
    {
		if(channel == PRIMITIZER_CHANNEL) // Main Channel
		{
			if(message == BUTTON_NEXT)
			{
				llDialog(id, DIALOG_MENU_MESSAGE, pagination(DIALOG_MENU_BUTTONS, BUTTON_NEXT), PRIMITIZER_CHANNEL);
				//llSetTimerEvent(timerOut);
			}
			else if(message == BUTTON_BACK)
			{
				// user clicked the BUTTON_BACK option, so get the previous
				// cycle of menu items
				llDialog(id, DIALOG_MENU_MESSAGE, pagination(DIALOG_MENU_BUTTONS, BUTTON_BACK), PRIMITIZER_CHANNEL);
				//llSetTimerEvent(timerOut);
			}
			else if(message == " ")
			{
				// user clicked the BUTTON_BACK option, so get the previous
				// cycle of menu items
				llDialog(id, DIALOG_MENU_MESSAGE, pagination(DIALOG_MENU_BUTTONS, ""), PRIMITIZER_CHANNEL);
				//llSetTimerEvent(timerOut);
			}
			else
			{
				integer index = llListFindList(DIALOG_MENU_BUTTONS, [message]);
				llMessageLinked(LINK_THIS, LINK_INTERFACE_RESPONSE, llList2String(DIALOG_MENU_RETURNS, index), id);
			}
		}
		if(channel == PRIMITIZER_CHANNEL)
		{
			//
		}
    }

    touch_start(integer total_number)
    {
        // display the dialog if the owner touched me
        if(llDetectedKey(0) == llGetOwner())
        {
            // display the dialog with the current menu cycle
            llDialog(llGetOwner(), DIALOG_MENU_MESSAGE, pagination(DIALOG_MENU_BUTTONS, ""), PRIMITIZER_CHANNEL);
        }
    }
}